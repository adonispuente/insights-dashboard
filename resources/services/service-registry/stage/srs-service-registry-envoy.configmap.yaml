---

apiVersion: v1
kind: ConfigMap
metadata:
  name: srs-service-registry-envoy-config
  annotations:
    qontract.recycle: "true"
data:
  main.yaml: |
    # The administration endpoint uses a Unix socket instead of TCP in order
    # to avoid exposing it outside of the pod. Requests for metrics and
    # probes will go via an HTTP listener that only accepts requests for the
    # /metrics and /ready paths.
    admin:
      access_log_path: /dev/null
      address:
        pipe:
          path: /sockets/admin.socket

    static_resources:

      clusters:

      # This backend is used to send metrics and probes requests to the
      # administration endpoint.
      - name: admin
        connect_timeout: 1s
        type: STATIC
        lb_policy: ROUND_ROBIN
        load_assignment:
          cluster_name: admin
          endpoints:
          - lb_endpoints:
            - endpoint:
                address:
                  pipe:
                    path: /sockets/admin.socket

      # This cluster is used to send requests to the backend. Note that
      # currently it uses plain TCP, because this communication is completely inside the pod
      - name: backend
        connect_timeout: 1s
        type: STATIC
        lb_policy: ROUND_ROBIN
        load_assignment:
          cluster_name: backend
          endpoints:
          - lb_endpoints:
            - endpoint:
                address:
                  socket_address:
                    address: 127.0.0.1
                    port_value: 8080 # SRS Service Registry port

      # This cluster is used to send request to the rate limiting service.
      - name: limiter
        connect_timeout: 1s
        type: STRICT_DNS
        lb_policy: ROUND_ROBIN
        http2_protocol_options: {}
        load_assignment:
          cluster_name: limiter
          endpoints:
          - lb_endpoints:
            - endpoint:
                address:
                  socket_address:
                    address: limitador.app-sre-rate-limiting.svc
                    port_value: 8081

      listeners:

      # This listener is used to accept /metrics and /ready requests.
      # Everything else will be rejected.
      - name: admin
        address:
          socket_address:
            address: 0.0.0.0
            port_value: 9000
        filter_chains:
        - filters:
          - name: envoy.filters.network.http_connection_manager
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
              stat_prefix: admin
              route_config:
                name: admin
                virtual_hosts:
                - name: admin
                  domains:
                  - "*"
                  routes:
                  - name: ready
                    match:
                      path: /ready
                    route:
                      cluster: admin
                  - name: metrics
                    match:
                      path: /metrics
                    route:
                      cluster: admin
                      prefix_rewrite: /stats/prometheus
              http_filters:
              - name: envoy.filters.http.router

      # This listener is used to accept inbound API requests.
      - name: ingress
        address:
          socket_address:
            address: 0.0.0.0
            port_value: 9001
        filter_chains:
        - transport_socket:
            name: envoy.transport_sockets.tls
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext
              common_tls_context:
                tls_certificates:
                - certificate_chain:
                    filename: /secrets/tls/tls.crt
                  private_key:
                    filename: /secrets/tls/tls.key
          filters:
          - name: envoy.filters.network.http_connection_manager
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
              access_log:
              - name: envoy.access_loggers.file
                typed_config:
                  "@type": type.googleapis.com/envoy.extensions.access_loggers.file.v3.FileAccessLog
                  path: /dev/stdout
              stat_prefix: ingress
              route_config:
                name: backend
                virtual_hosts:
                - name: all
                  domains:
                  - "*"
                  routes:

                  # Apply rate limit to each tenant
                  - name: apicurio-tenants
                    match:
                      safe_regex:
                        regex: "\/t\/.+\/apis\/.*"
                        google_re2: {}
                    route:
                      cluster: backend
                      rate_limits:
                      # normal plan rate limit
                      - actions:
                        - generic_key:
                            descriptor_key: component
                            descriptor_value: srs_service_registry
                        - request_headers:
                            descriptor_key: tenant_id
                            header_name: X-Registry-Tenant-Id
                        - request_headers:
                            descriptor_key: rate_limit
                            header_name: X-Registry-Rate-Limit

                  # This is an example of how to define a rate limit for a
                  # specific path.
                  # - name: my_path
                  #   match:
                  #     path: /my_path
                  #   route:
                  #     cluster: backend
                  #     rate_limits:
                  #     - actions:
                  #       - generic_key:
                  #           descriptor_key: example_descriptor_key
                  #           descriptor_value: example_descriptor_value

                  # endpoints required for apidocs
                  # it's rate limited by a local rate limit to avoid over loading the ratelimit service
                  - name: apis-web-resources
                    match:
                      prefix: /apis
                    route:
                      cluster: backend
                    typed_per_filter_config:
                      envoy.filters.http.local_ratelimit:
                        "@type": type.googleapis.com/envoy.extensions.filters.http.local_ratelimit.v3.LocalRateLimit
                        stat_prefix: http_local_rate_limiter
                        token_bucket:
                          max_tokens: 3000
                          tokens_per_fill: 3000
                          fill_interval: 10s
                        filter_enabled:
                          runtime_key: local_rate_limit_enabled
                          default_value:
                            numerator: 100
                            denominator: HUNDRED
                        filter_enforced:
                          runtime_key: local_rate_limit_enforced
                          default_value:
                            numerator: 100
                            denominator: HUNDRED
                  - name: api-specifications
                    match:
                      prefix: /api-specifications
                    route:
                      cluster: backend
                    typed_per_filter_config:
                      envoy.filters.http.local_ratelimit:
                        "@type": type.googleapis.com/envoy.extensions.filters.http.local_ratelimit.v3.LocalRateLimit
                        stat_prefix: http_local_rate_limiter
                        token_bucket:
                          max_tokens: 3000
                          tokens_per_fill: 3000
                          fill_interval: 10s
                        filter_enabled:
                          runtime_key: local_rate_limit_enabled
                          default_value:
                            numerator: 100
                            denominator: HUNDRED
                        filter_enforced:
                          runtime_key: local_rate_limit_enforced
                          default_value:
                            numerator: 100
                            denominator: HUNDRED
                  - name: web-resources
                    match:
                      prefix: /resources
                    route:
                      cluster: backend
                    typed_per_filter_config:
                      envoy.filters.http.local_ratelimit:
                        "@type": type.googleapis.com/envoy.extensions.filters.http.local_ratelimit.v3.LocalRateLimit
                        stat_prefix: http_local_rate_limiter
                        token_bucket:
                          max_tokens: 3000
                          tokens_per_fill: 3000
                          fill_interval: 10s
                        filter_enabled:
                          runtime_key: local_rate_limit_enabled
                          default_value:
                            numerator: 100
                            denominator: HUNDRED
                        filter_enforced:
                          runtime_key: local_rate_limit_enforced
                          default_value:
                            numerator: 100
                            denominator: HUNDRED
                  - name: favicon
                    match:
                      prefix: /favicon.ico
                    route:
                      cluster: backend
                    typed_per_filter_config:
                      envoy.filters.http.local_ratelimit:
                        "@type": type.googleapis.com/envoy.extensions.filters.http.local_ratelimit.v3.LocalRateLimit
                        stat_prefix: http_local_rate_limiter
                        token_bucket:
                          max_tokens: 3000
                          tokens_per_fill: 3000
                          fill_interval: 10s
                        filter_enabled:
                          runtime_key: local_rate_limit_enabled
                          default_value:
                            numerator: 100
                            denominator: HUNDRED
                        filter_enforced:
                          runtime_key: local_rate_limit_enforced
                          default_value:
                            numerator: 100
                            denominator: HUNDRED
                  # Everything else not matching one of the rules above it's rejected

              http_filters:

              #custom lua filter to parse the path and set the tenantId as a header
              - name: envoy.filters.http.lua
                typed_config:
                  "@type": type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua
                  inline_code: |
                    -- Source: https://github.com/rxi/json.lua/blob/11077824d7cfcd28a4b2f152518036b295e7e4ce/json.lua
                    function load_json()
                      --
                      -- json.lua
                      --
                      -- Copyright (c) 2020 rxi
                      --
                      -- Permission is hereby granted, free of charge, to any person obtaining a copy of
                      -- this software and associated documentation files (the "Software"), to deal in
                      -- the Software without restriction, including without limitation the rights to
                      -- use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
                      -- of the Software, and to permit persons to whom the Software is furnished to do
                      -- so, subject to the following conditions:
                      --
                      -- The above copyright notice and this permission notice shall be included in all
                      -- copies or substantial portions of the Software.
                      --
                      -- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                      -- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                      -- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                      -- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                      -- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                      -- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
                      -- SOFTWARE.
                      --

                      local json = { _version = "0.1.2" }

                      -------------------------------------------------------------------------------
                      -- Encode
                      -------------------------------------------------------------------------------

                      local encode

                      local escape_char_map = {
                        [ "\\" ] = "\\",
                        [ "\"" ] = "\"",
                        [ "\b" ] = "b",
                        [ "\f" ] = "f",
                        [ "\n" ] = "n",
                        [ "\r" ] = "r",
                        [ "\t" ] = "t",
                      }

                      local escape_char_map_inv = { [ "/" ] = "/" }
                      for k, v in pairs(escape_char_map) do
                        escape_char_map_inv[v] = k
                      end


                      local function escape_char(c)
                        return "\\" .. (escape_char_map[c] or string.format("u%04x", c:byte()))
                      end


                      local function encode_nil(val)
                        return "null"
                      end


                      local function encode_table(val, stack)
                        local res = {}
                        stack = stack or {}

                        -- Circular reference?
                        if stack[val] then error("circular reference") end

                        stack[val] = true

                        if rawget(val, 1) ~= nil or next(val) == nil then
                          -- Treat as array -- check keys are valid and it is not sparse
                          local n = 0
                          for k in pairs(val) do
                            if type(k) ~= "number" then
                              error("invalid table: mixed or invalid key types")
                            end
                            n = n + 1
                          end
                          if n ~= #val then
                            error("invalid table: sparse array")
                          end
                          -- Encode
                          for i, v in ipairs(val) do
                            table.insert(res, encode(v, stack))
                          end
                          stack[val] = nil
                          return "[" .. table.concat(res, ",") .. "]"

                        else
                          -- Treat as an object
                          for k, v in pairs(val) do
                            if type(k) ~= "string" then
                              error("invalid table: mixed or invalid key types")
                            end
                            table.insert(res, encode(k, stack) .. ":" .. encode(v, stack))
                          end
                          stack[val] = nil
                          return "{" .. table.concat(res, ",") .. "}"
                        end
                      end


                      local function encode_string(val)
                        return '"' .. val:gsub('[%z\1-\31\\"]', escape_char) .. '"'
                      end


                      local function encode_number(val)
                        -- Check for NaN, -inf and inf
                        if val ~= val or val <= -math.huge or val >= math.huge then
                          error("unexpected number value '" .. tostring(val) .. "'")
                        end
                        return string.format("%.14g", val)
                      end


                      local type_func_map = {
                        [ "nil"     ] = encode_nil,
                        [ "table"   ] = encode_table,
                        [ "string"  ] = encode_string,
                        [ "number"  ] = encode_number,
                        [ "boolean" ] = tostring,
                      }


                      encode = function(val, stack)
                        local t = type(val)
                        local f = type_func_map[t]
                        if f then
                          return f(val, stack)
                        end
                        error("unexpected type '" .. t .. "'")
                      end


                      function json.encode(val)
                        return ( encode(val) )
                      end


                      -------------------------------------------------------------------------------
                      -- Decode
                      -------------------------------------------------------------------------------

                      local parse

                      local function create_set(...)
                        local res = {}
                        for i = 1, select("#", ...) do
                          res[ select(i, ...) ] = true
                        end
                        return res
                      end

                      local space_chars   = create_set(" ", "\t", "\r", "\n")
                      local delim_chars   = create_set(" ", "\t", "\r", "\n", "]", "}", ",")
                      local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")
                      local literals      = create_set("true", "false", "null")

                      local literal_map = {
                        [ "true"  ] = true,
                        [ "false" ] = false,
                        [ "null"  ] = nil,
                      }


                      local function next_char(str, idx, set, negate)
                        for i = idx, #str do
                          if set[str:sub(i, i)] ~= negate then
                            return i
                          end
                        end
                        return #str + 1
                      end


                      local function decode_error(str, idx, msg)
                        local line_count = 1
                        local col_count = 1
                        for i = 1, idx - 1 do
                          col_count = col_count + 1
                          if str:sub(i, i) == "\n" then
                            line_count = line_count + 1
                            col_count = 1
                          end
                        end
                        error( string.format("%s at line %d col %d", msg, line_count, col_count) )
                      end


                      local function codepoint_to_utf8(n)
                        -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
                        local f = math.floor
                        if n <= 0x7f then
                          return string.char(n)
                        elseif n <= 0x7ff then
                          return string.char(f(n / 64) + 192, n % 64 + 128)
                        elseif n <= 0xffff then
                          return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
                        elseif n <= 0x10ffff then
                          return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                                             f(n % 4096 / 64) + 128, n % 64 + 128)
                        end
                        error( string.format("invalid unicode codepoint '%x'", n) )
                      end


                      local function parse_unicode_escape(s)
                        local n1 = tonumber( s:sub(1, 4),  16 )
                        local n2 = tonumber( s:sub(7, 10), 16 )
                         -- Surrogate pair?
                        if n2 then
                          return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
                        else
                          return codepoint_to_utf8(n1)
                        end
                      end


                      local function parse_string(str, i)
                        local res = ""
                        local j = i + 1
                        local k = j

                        while j <= #str do
                          local x = str:byte(j)

                          if x < 32 then
                            decode_error(str, j, "control character in string")

                          elseif x == 92 then -- `\`: Escape
                            res = res .. str:sub(k, j - 1)
                            j = j + 1
                            local c = str:sub(j, j)
                            if c == "u" then
                              local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                                       or str:match("^%x%x%x%x", j + 1)
                                       or decode_error(str, j - 1, "invalid unicode escape in string")
                              res = res .. parse_unicode_escape(hex)
                              j = j + #hex
                            else
                              if not escape_chars[c] then
                                decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
                              end
                              res = res .. escape_char_map_inv[c]
                            end
                            k = j + 1

                          elseif x == 34 then -- `"`: End of string
                            res = res .. str:sub(k, j - 1)
                            return res, j + 1
                          end

                          j = j + 1
                        end

                        decode_error(str, i, "expected closing quote for string")
                      end


                      local function parse_number(str, i)
                        local x = next_char(str, i, delim_chars)
                        local s = str:sub(i, x - 1)
                        local n = tonumber(s)
                        if not n then
                          decode_error(str, i, "invalid number '" .. s .. "'")
                        end
                        return n, x
                      end


                      local function parse_literal(str, i)
                        local x = next_char(str, i, delim_chars)
                        local word = str:sub(i, x - 1)
                        if not literals[word] then
                          decode_error(str, i, "invalid literal '" .. word .. "'")
                        end
                        return literal_map[word], x
                      end


                      local function parse_array(str, i)
                        local res = {}
                        local n = 1
                        i = i + 1
                        while 1 do
                          local x
                          i = next_char(str, i, space_chars, true)
                          -- Empty / end of array?
                          if str:sub(i, i) == "]" then
                            i = i + 1
                            break
                          end
                          -- Read token
                          x, i = parse(str, i)
                          res[n] = x
                          n = n + 1
                          -- Next token
                          i = next_char(str, i, space_chars, true)
                          local chr = str:sub(i, i)
                          i = i + 1
                          if chr == "]" then break end
                          if chr ~= "," then decode_error(str, i, "expected ']' or ','") end
                        end
                        return res, i
                      end


                      local function parse_object(str, i)
                        local res = {}
                        i = i + 1
                        while 1 do
                          local key, val
                          i = next_char(str, i, space_chars, true)
                          -- Empty / end of object?
                          if str:sub(i, i) == "}" then
                            i = i + 1
                            break
                          end
                          -- Read key
                          if str:sub(i, i) ~= '"' then
                            decode_error(str, i, "expected string for key")
                          end
                          key, i = parse(str, i)
                          -- Read ':' delimiter
                          i = next_char(str, i, space_chars, true)
                          if str:sub(i, i) ~= ":" then
                            decode_error(str, i, "expected ':' after key")
                          end
                          i = next_char(str, i + 1, space_chars, true)
                          -- Read value
                          val, i = parse(str, i)
                          -- Set
                          res[key] = val
                          -- Next token
                          i = next_char(str, i, space_chars, true)
                          local chr = str:sub(i, i)
                          i = i + 1
                          if chr == "}" then break end
                          if chr ~= "," then decode_error(str, i, "expected '}' or ','") end
                        end
                        return res, i
                      end


                      local char_func_map = {
                        [ '"' ] = parse_string,
                        [ "0" ] = parse_number,
                        [ "1" ] = parse_number,
                        [ "2" ] = parse_number,
                        [ "3" ] = parse_number,
                        [ "4" ] = parse_number,
                        [ "5" ] = parse_number,
                        [ "6" ] = parse_number,
                        [ "7" ] = parse_number,
                        [ "8" ] = parse_number,
                        [ "9" ] = parse_number,
                        [ "-" ] = parse_number,
                        [ "t" ] = parse_literal,
                        [ "f" ] = parse_literal,
                        [ "n" ] = parse_literal,
                        [ "[" ] = parse_array,
                        [ "{" ] = parse_object,
                      }


                      parse = function(str, idx)
                        local chr = str:sub(idx, idx)
                        local f = char_func_map[chr]
                        if f then
                          return f(str, idx)
                        end
                        decode_error(str, idx, "unexpected character '" .. chr .. "'")
                      end


                      function json.decode(str)
                        if type(str) ~= "string" then
                          error("expected argument of type string, got " .. type(str))
                        end
                        local res, idx = parse(str, next_char(str, 1, space_chars, true))
                        idx = next_char(str, idx, space_chars, true)
                        if idx <= #str then
                          decode_error(str, idx, "trailing garbage")
                        end
                        return res
                      end


                      return json

                    end
                    json = load_json()

                    function add_default_rate_limit(request_handle, tenant_id)
                      local default_limit = 10
                      request_handle:logInfo("Using default " .. default_limit .. " req/s rate limit for tenant " .. tenant_id)
                      request_handle:headers():add("X-Registry-Rate-Limit", default_limit)
                    end

                    function add_rate_limit(request_handle, tenant_id)
                      local headers, body = request_handle:httpCall(
                        "backend",
                        {
                          [":method"] = "GET",
                          [":path"] = "/t/" .. tenant_id .. "/apis/registry/v2/system/limits",
                          [":authority"] = "backend",
                          ["Content-Type"] = "text/plain"
                        },
                        nil,
                        1000)

                      if headers[":status"] == "200" then
                        local data = json.decode(body)
                        local limit = data["maxRequestsPerSecondCount"]
                        if limit ~= nil then
                          request_handle:logInfo("Using " .. limit .. " req/s rate limit for tenant " .. tenant_id)
                          request_handle:headers():add("X-Registry-Rate-Limit", limit)
                        else
                          add_default_rate_limit(request_handle, tenant_id)
                        end
                      else
                        add_default_rate_limit(request_handle, tenant_id)
                      end
                    end

                    function envoy_on_request(request_handle)
                      local path = request_handle:headers():get(":path")
                      local delimiter = "/"
                      local tid_delimiter = false
                      local index = 0
                      for item in (path..delimiter):gmatch("(.-)"..delimiter) do
                        if index == 0 then
                        elseif index == 1 and item == "t" then
                          tid_delimiter = true
                        elseif index == 2 and tid_delimiter and item ~= "" then
                          request_handle:logInfo("Extracted tenantId " .. item)
                          request_handle:headers():add("X-Registry-Tenant-Id", item)
                          add_rate_limit(request_handle, item)
                          return
                        else
                          add_default_rate_limit(request_handle, "unknown")
                          return
                        end
                        index = index + 1
                      end
                    end

              # config for main safety local rate limit
              - name: envoy.filters.http.local_ratelimit
                typed_config:
                  "@type": type.googleapis.com/envoy.extensions.filters.http.local_ratelimit.v3.LocalRateLimit
                  stat_prefix: http_local_rate_limiter


              # This is needed to enable the rate limiter:
              - name: envoy.filters.http.ratelimit
                typed_config:
                  "@type": type.googleapis.com/envoy.extensions.filters.http.ratelimit.v3.RateLimit
                  domain: stage:srs_service_registry # This changes by environment
                  failure_mode_deny: false
                  timeout: 0.05s
                  rate_limit_service:
                    grpc_service:
                      envoy_grpc:
                        cluster_name: limiter
                    transport_api_version: V3

              # This is mandatory in order to have the HTTP routes above.
              - name: envoy.filters.http.router

              # We need this in order to generate JSON responses according to
              # our API guidelines, otherwise Envoy will generate plain text
              # responses.
              local_reply_config:
                mappers:
                - filter:
                    status_code_filter:
                      comparison:
                        op: EQ
                        value:
                          default_value: 429
                          runtime_key: none
                  body_format_override:
                    json_format:
                      kind: "Error"
                      id: "429"
                      code: "SERVICEREGISTRY-429"
                      reason: "Too Many Requests"
