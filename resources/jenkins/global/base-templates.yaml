- base_templates:
    name: base-templates

    build_deploy: &build_deploy
        shell: |
            {build_deploy_script_path}

    saasherder_apply: &saasherder_apply
        shell: |
            #!/bin/bash
            set -e

            if [[ ! -z "{kube_cluster}" && ! -z "{saasherder_context}" && \
                ! -z "{saas_git}" && ! -z "{saasherder_services}" ]]; then

                SAAS_GIT="$(echo {saas_git} | sed "s|//|//$APP_SRE_BOT_USER:$APP_SRE_BOT_PUSH_TOKEN@|g")"
                git clone --depth 1 $SAAS_GIT saas.git

                if [ -n "{ssh_ci_ext}" ]; then SSH_CMD="{ssh_ci_ext_cmd}"; else SSH_CMD=""; fi

                #Deploy preview
                SAAS_ENV={saas_env}
                cd saas.git
                for service in {saasherder_services}; do
                    {saasherder_docker} --context "{saasherder_context}" --environment $SAAS_ENV update hash ${{service}} $GIT_COMMIT
                    {saasherder_docker} --context "{saasherder_context}" --environment $SAAS_ENV pull ${{service}}
                    {saasherder_docker} --context "{saasherder_context}" --environment $SAAS_ENV template --filter {saasherder_object_blacklist} --output-dir {saasherder_context}-processed --local tag ${{service}}
                    {saasherder_docker} --context "{saasherder_context}" --environment $SAAS_ENV label --output-dir {saasherder_context}-processed --saas-repo-url {saas_git} ${{service}} > label_selector

                    cat {saasherder_context}-processed/${{service}}.yaml | $SSH_CMD oc --server="$KUBE_SERVER" --token="$KUBE_TOKEN" apply -f - -n {kube_namespace} --dry-run --validate
                    cat {saasherder_context}-processed/${{service}}.yaml | $SSH_CMD oc --server="$KUBE_SERVER" --token="$KUBE_TOKEN" apply -f - -n {kube_namespace}

                    if [ "{kube_namespace}" == "error_no_ns" ]; then continue; fi

                    label_selector=$(cat label_selector)

                    # validate that the number of replicas matches the number of ready replicas
                    if [ -z "{disable_saasherder_validate}" ]; then
                        current_label_selector=$(echo $label_selector | sed 's/!=/==/g')
                        resources_to_validate=$($SSH_CMD oc --server="$KUBE_SERVER" --token="$KUBE_TOKEN" get {saasherder_object_validate} -o name -l "$current_label_selector" -n {kube_namespace})

                        STATUS=invalid
                        ATTEMPT=0
                        MAX_ATTEMPTS={saasherder_validate_max_attempts} # total sleep time is (( MAX_ATTEMPTS * (MAX_ATTEMPTS+1) ) / 2)
                        until [[ "$STATUS" == "valid" || $ATTEMPT -ge $MAX_ATTEMPTS ]]; do
                            STATUS=valid
                            sleep $(( ATTEMPT++ )) # first sleep is 0
                            for r in $resources_to_validate; do
                                echo "validating $r"
                                replicas_status=$($SSH_CMD oc --server="$KUBE_SERVER" --token="$KUBE_TOKEN" -n {kube_namespace} get $r -o jsonpath="{{['status.replicas', 'status.readyReplicas', 'status.updatedReplicas']}}")

                                if [ "$(echo $replicas_status | wc -w)" != "3" ]; then
                                    echo "replica status invalid, status is invalid"
                                    STATUS=invalid
                                    continue
                                fi

                                replicas=$(echo $replicas_status | cut -d' ' -f1)
                                ready_replicas=$(echo $replicas_status | cut -d' ' -f2)
                                updated_replicas=$(echo $replicas_status | cut -d' ' -f3)

                                if [[ "$replicas" != "$ready_replicas" || "$replicas" != "$updated_replicas" ]]; then
                                    echo "new replicas not ready, status is invalid"
                                    STATUS=invalid
                                    continue
                                fi
                            done
                        done

                        if [ "$STATUS" == "invalid" ]; then exit 1; fi
                    fi

                    # delete resources from previous deployments that are no longer deployed
                    if [ -z "{disable_saasherder_delete}" ]; then
                        resources_to_delete=$($SSH_CMD oc --server="$KUBE_SERVER" --token="$KUBE_TOKEN" get {saasherder_object_whitelist} -o name -l "$label_selector" -n {kube_namespace})

                        for r in $resources_to_delete; do
                            echo DRY-RUN oc delete $r -n {kube_namespace}
                        done
                    fi
                done
                cd ..
            fi

    saasherder_promote: &saasherder_promote
        shell: |
            #!/bin/bash
            set -e

            if [ -z "{auto_promote}" ]; then exit; fi

            BRANCH="promote-$GIT_COMMIT"
            if [ "$(git ls-remote --heads {saas_git} $BRANCH | wc -l)" != "0" ]; then
                echo remote branch promote-$GIT_COMMIT exists, exiting.
                exit
            fi

            cd saas.git
            git config --global user.email "$APP_SRE_BOT_EMAIL"
            git config --global user.name "$APP_SRE_BOT_USER"
            git checkout -b $BRANCH
            git add {saasherder_context}-services
            git commit -m "promote $GIT_COMMIT"
            git remote add auth $(echo {saas_git} | sed "s|//|//$APP_SRE_BOT_USER:$APP_SRE_BOT_PUSH_TOKEN@|g")
            git push auth $BRANCH
            cd ..

    build_master_builder: &build_master_builder
        disabled: '{disable}'
        kube_cluster: ''
        kube_namespace: 'error_no_ns'
        saasherder_context: ''
        saasherder_services: ''
        build_deploy_script_path: './build_deploy.sh'
        ssh_ci_ext: ''
        auto_promote: ''
        disable_saasherder_validate: ''
        disable_saasherder_delete: ''
        saas_git: ''
        saas_git_private: ''
        saas_env: 'staging'
        wrappers:
        - timeout_wrapper:
            timeout: '{timeout}'
        builders:
        - *build_deploy
        - *saasherder_apply
        - *saasherder_promote
        - *saasherder_create_pr

    # Defines the saasherder shell build script that implements CD
    #
    # Arguments:
    #
    # saasherder_context:
    #    The name of the context in the saasherder repo, as defined in the
    #    config.yaml file.
    # dry_run:
    #   If `yes` => it will not perform the deployment.
    # image_pattern:
    #   Enforce that the images reference by the deployment files
    #   match this regexp. Example: '^quay\.io/app-sre/'. If empty, any image url
    #   will be valid.
    # kube_namespace:
    #   Namespace to deploy to.
    #
    # Additionally, any job or job-template that includes this definition must
    # define secrets which export:
    # - KUBE_SERVER
    # - KUBE_TOKEN
    saasherder: &saasherder
        kube_namespace: "error_no_ns"
        ssh_ci_ext: ''
        disable_saasherder_validate: ''
        disable_saasherder_delete: ''
        saas_env: 'production'
        repo_url: ''
        builders:
        - shell: |
            #!/bin/bash
            set -e

            # Ensure $KUBE_SERVER and $KUBE_TOKEN are defined
            if [[ -z "$KUBE_SERVER" || -z "$KUBE_TOKEN" ]]; then
                echo 'Missing secret that defines $KUBE_SERVER and $KUBE_TOKEN'
                exit 1
            fi

            if [[ -z "{saasherder_context}" ]]; then
                echo '{{saasherder_context}} not defined'
                exit 1
            fi

            SAAS_ENV={saas_env}
            PROCESSED_DIR="{saasherder_context}-processed"

            {saasherder_docker} --context "{saasherder_context}" --environment "$SAAS_ENV" pull
            {saasherder_docker} --context "{saasherder_context}" --environment "$SAAS_ENV" template --filter {saasherder_object_blacklist} --output-dir "$PROCESSED_DIR" --local tag
            {saasherder_docker} --context "{saasherder_context}" --environment "$SAAS_ENV" label --output-dir "$PROCESSED_DIR" --saas-repo-url {repo_url} > label_selectors

            if [ -n "{ssh_ci_ext}" ]; then SSH_CMD="{ssh_ci_ext_cmd}"; else SSH_CMD=""; fi

            find $PROCESSED_DIR -type f | while read f; do
                cat $f | $SSH_CMD oc --server="$KUBE_SERVER" --token="$KUBE_TOKEN" -n {kube_namespace} apply --dry-run --validate -f -

                {saasherder_check_image} $f '{image_pattern}'
                cat $f | {manifest_bouncer_cmd}

                if [ "{dry_run}" != "yes" ]; then
                    cat $f | $SSH_CMD oc --server="$KUBE_SERVER" --token="$KUBE_TOKEN" -n {kube_namespace} apply -f -
                fi
            done

            if [ "{dry_run}" == "yes" ]; then exit; fi
            if [ "{kube_namespace}" == "error_no_ns" ]; then exit; fi

            # validate that the number of replicas matches the number of ready replicas
            if [ -z "{disable_saasherder_validate}" ]; then
                STATUS=invalid
                ATTEMPT=0
                MAX_ATTEMPTS={saasherder_validate_max_attempts} # total sleep time is (( MAX_ATTEMPTS * (MAX_ATTEMPTS+1) ) / 2)
                until [[ "$STATUS" == "valid" || $ATTEMPT -ge $MAX_ATTEMPTS ]]; do
                    STATUS=valid
                    sleep $(( ATTEMPT++ )) # first sleep is 0
                    while IFS= read -r label_selector; do
                        current_label_selector=$(echo $label_selector | sed 's/!=/==/g')
                        resources_to_validate=$($SSH_CMD oc --server="$KUBE_SERVER" --token="$KUBE_TOKEN" get {saasherder_object_validate} -o name -l "$current_label_selector" -n {kube_namespace})

                        for r in $resources_to_validate; do
                            echo "validating $r"
                            replicas_status=$($SSH_CMD oc --server="$KUBE_SERVER" --token="$KUBE_TOKEN" -n {kube_namespace} get $r -o jsonpath="{{['status.replicas', 'status.readyReplicas', 'status.updatedReplicas']}}")

                            if [ "$(echo $replicas_status | wc -w)" != "3" ]; then
                                echo "replica status invalid, status is invalid"
                                STATUS=invalid
                                continue
                            fi

                            replicas=$(echo $replicas_status | cut -d' ' -f1)
                            ready_replicas=$(echo $replicas_status | cut -d' ' -f2)
                            updated_replicas=$(echo $replicas_status | cut -d' ' -f3)

                            if [[ "$replicas" != "$ready_replicas" || "$replicas" != "$updated_replicas" ]]; then
                                echo "new replicas not ready, status is invalid"
                                STATUS=invalid
                                continue
                            fi
                        done
                    done < label_selectors
                done

                if [ "$STATUS" == "invalid" ]; then exit 1; fi
            fi

            # delete resources from previous deployments that are no longer deployed
            if [ -z "{disable_saasherder_delete}" ]; then
                while IFS= read -r label_selector; do
                    resources_to_delete=$($SSH_CMD oc --server="$KUBE_SERVER" --token="$KUBE_TOKEN" get {saasherder_object_whitelist} -o name -l "$label_selector" -n {kube_namespace})

                    for r in $resources_to_delete; do
                        echo DRY-RUN oc delete $r -n {kube_namespace}
                    done
                done < label_selectors
            fi

- base_templates:
    name: github-base-templates

    gh_checkout: &gh_checkout
        branch: "master"
        node: '{node}'
        properties:
        - github:
            url: 'https://github.com/{gh_org}/{gh_repo}/'
        scm:
        - git:
            url: 'https://github.com/{gh_org}/{gh_repo}.git'
            branches:
                - '{branch}'

    gh_build_master: &gh_build_master
        <<: *gh_checkout
        <<: *build_master_builder

    gh_pr_check: &gh_pr_check
        node: '{node}'
        concurrent: '{concurrent_build}'
        pr_check_script_path: "./pr_check.sh"
        status_context: "ci.ext.devshift.net PR build"
        properties:
        - github:
            url: 'https://github.com/{gh_org}/{gh_repo}/'
        triggers:
          - github-pull-request:
              cron: '* * * * *'
              github-hooks: true
              permit-all: false
              trigger-phrase: '(?ms).*^(\[test\]|\/retest)\s*$.*'
              org-list:
              - app-sre
              - openshift
              allow-whitelist-orgs-as-admins: true
              status-context: '{status_context}'
        wrappers:
        - timeout_wrapper:
            timeout: '{timeout}'
        scm:
        - git:
            url: 'https://github.com/{gh_org}/{gh_repo}.git'
            skip-tag: true
            refspec: '+refs/pull/*:refs/remotes/origin/pr/*'
            branches:
                - '${{ghprbActualCommit}}'
            merge:
                remote: origin
                branch: master
            git-config-name: "AppSRE"
            git-config-email: "sd-app-sre@redhat.com"
        builders:
        - shell: |
            {pr_check_script_path}

    gh_timed: &gh_timed
        ci_cmd: ./run.sh
        wrappers:
        - timeout_wrapper:
            timeout: '{timeout}'
        builders:
        - shell: |
            {ci_cmd}
        triggers:
        - timed: |
            {cron_expression}
        <<: *gh_checkout

- base_templates:
    name: gitlab-base-templates

    gl_checkout: &gl_checkout
        branch: "master"
        node: '{node}'
        properties:
        - github:
            url: 'https://gitlab.cee.redhat.com/{gl_group}/{gl_project}.git'
        - gitlab:
            connection: 'gitlab cee'
        scm:
        - git:
            url: 'git@gitlab.cee.redhat.com:{gl_group}/{gl_project}.git'
            credentials-id: '{gitlab_ssh_credentials}'
            shallow_clone: true
            branches:
            - '{branch}'

    gl_build_master_template: &gl_build_master_template
        triggers:
        - gitlab:
            trigger-push: true
            trigger-merge-request: false
            trigger-open-merge-request-push: never
            add-note-merge-request: false
            add-ci-message: false
            set-build-description: true
            add-vote-merge-request: false
            trigger-note: false
            ci-skip: false
            wip-skip: false
            branch-filter-type: "NameBasedFilter"
            include-branches:
            - '{branch}'
        <<: *gl_checkout
        <<: *build_master_builder

    gl_pr_check_template: &gl_pr_check_template
        node: '{node}'
        pr_check_script_path: "./pr_check.sh"
        properties:
        - github:
            url: 'https://gitlab.cee.redhat.com/{gl_group}/{gl_project}.git'
        - gitlab:
            connection: 'gitlab cee'
        scm:
        - git:
            remotes:
            - 'origin':
                url: 'https://gitlab.cee.redhat.com/{gl_group}/{gl_project}.git'
                credentials-id: '{gitlab_ssh_credentials}'
                refspec: '+refs/heads/*:refs/remotes/origin/* +refs/merge-requests/*/head:refs/remotes/origin/merge-requests/*'
            branches:
            - 'merge-requests/${{gitlabMergeRequestIid}}'
            merge:
                remote: 'origin'
                branch: '${{gitlabTargetBranch}}'
        triggers:
        - gitlab:
            trigger-push: true
            trigger-merge-request: true
            trigger-open-merge-request-push: source
            note-regex: '(?ms).*^(\[test\]|\/retest)\s*$.*'
            set-build-description: true
            add-note-merge-request: true
            add-vote-merge-request: true
            add-ci-message: true
            allow-all-branches: true
            ci-skip: true
            wip-skip: true
        wrappers:
        - timeout_wrapper:
            timeout: '{timeout}'
        publishers:
        - gitlab_message
        - gitlab-notifier
        concurrent: '{concurrent_build}'
        builders:
        - shell: |
            {pr_check_script_path}

    gl_timed_template: &gl_timed_template
        ci_cmd: ./run.sh
        wrappers:
        - timeout_wrapper:
            timeout: '{timeout}'
        builders:
        - shell: |
            {ci_cmd}
        triggers:
        - timed: |
            {cron_expression}
        <<: *gl_checkout

    # This template is intended to create jobs that run the pipeline described
    # in the 'Jenkinsfile' of the project when changes are merged to the master
    # branch.
    gl_build_pipeline_template: &gl_build_pipeline_template
        project-type: pipeline
        pipeline-scm:
          scm:
          - git:
              url: 'git@gitlab.cee.redhat.com/{gl_group}/{gl_project}.git'
              credentials-id: '{gitlab_ssh_credentials}'
              shallow_clone: true
              branches:
              - '{branch}'
        triggers:
        - pollscm:
            cron: '* * * * *'
        wrappers:
        - timeout_wrapper:
            timeout: '{timeout}'
        <<: *gl_checkout
